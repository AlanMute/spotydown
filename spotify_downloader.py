import os
import re
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import yt_dlp as youtube_dl
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TALB, APIC, error
import urllib.request
import concurrent.futures
import argparse
import time
from difflib import SequenceMatcher
import threading
import json
from http.cookiejar import MozillaCookieJar
import selenium
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
import undetected_chromedriver as uc
import tempfile
import shutil
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, IntPrompt, Confirm
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeElapsedColumn
from rich.theme import Theme
from single_track_cli import (
    set_console as st_set_console,
    cli_download_single_track,
)
from app_config import ensure_music_dir, change_music_dir, load_config, save_config


CLIENT_ID = '77bb678c39844763a230d7452c3b3f5e'
CLIENT_SECRET = '942b953998a4486f91febf938aa06989'
BASE_MUSIC_DIR = None

DEBUG = False

THEME = Theme({
    "ok": "bold green",
    "warn": "bold yellow",
    "err": "bold red",
    "title": "bold cyan",
    "muted": "dim",
})
console = Console(theme=THEME)
st_set_console(console)


CLI_SETTINGS = {
    "threads": 3,
    "debug": False,
}

SEARCH_CACHE = {}

cookies_lock = threading.Lock()
cookies_last_checked = 0
COOKIES_CHECK_INTERVAL = 1800  

COOKIES_NEED_REFRESH = False

def sanitize_filename(name):
    return re.sub(r'[\\/*?:"<>|]', "", name)



def automate_youtube_login(driver, email, password, timeout=30):
    """Устойчивый вход в YouTube/Google-аккаунт"""
    from selenium.common.exceptions import TimeoutException
    driver.get(
        "https://accounts.google.com/signin/v2/identifier"
        "?service=youtube&hl=ru&passive=true&continue=https://www.youtube.com/"
    )
    wait = WebDriverWait(driver, timeout)

    def safe_click_any(selectors):
        for by, sel in selectors:
            try:
                el = wait.until(EC.element_to_be_clickable((by, sel)))
                driver.execute_script("arguments[0].scrollIntoView({block:'center'});", el)
                el.click()
                return True
            except Exception:
                continue
        return False

    def accept_consents():
        selectors = [
            (By.CSS_SELECTOR, "button#accept-button"),                   
            (By.CSS_SELECTOR, "button[aria-label*='Accept']"),
            (By.CSS_SELECTOR, "button[aria-label*='Принять']"),
            (By.ID, "introAgreeButton"),                                
            (By.XPATH, "//button[contains(., 'I agree')]"),
            (By.XPATH, "//button[contains(., 'Accept all')]"),
            (By.XPATH, "//button[contains(., 'Я принимаю')]"),
            (By.XPATH, "//button[contains(., 'Принять все')]"),
        ]
        safe_click_any(selectors)

    def js_set_value(el, value):
        driver.execute_script("arguments[0].value = arguments[1];", el, value)

    try:
        accept_consents()

        email_box = wait.until(EC.visibility_of_element_located((By.ID, "identifierId")))
        driver.execute_script("arguments[0].scrollIntoView({block:'center'});", email_box)
        try:
            email_box.clear()
            email_box.send_keys(email)
        except Exception:
            js_set_value(email_box, email)

        safe_click_any([(By.ID, "identifierNext")])

        accept_consents()

        passwd_box = wait.until(EC.visibility_of_element_located((By.NAME, "Passwd")))
        driver.execute_script("arguments[0].scrollIntoView({block:'center'});", passwd_box)
        try:
            passwd_box.clear()
            passwd_box.send_keys(password)
        except Exception:
            js_set_value(passwd_box, password)

        safe_click_any([(By.ID, "passwordNext")])

        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "#avatar-btn")))
        return True
    except TimeoutException as e:
        print(f"Ошибка автоматического входа (таймаут): {e}")
        return False
    except Exception as e:
        print(f"Ошибка автоматического входа: {e}")
        return False


def export_cookies_selenium(driver, cookies_path):
    """Экспортирует cookies из Selenium в Netscape-формат для yt-dlp"""
    try:
        cookies = driver.get_cookies()
        with open(cookies_path, 'w', encoding='utf-8') as f:
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# This file was generated by Spotify Downloader\n\n")

            for c in cookies:
                domain = c.get('domain', '')
                if not domain.startswith('.'):
                    domain = '.' + domain

                path = c.get('path', '/')
                secure = 'TRUE' if c.get('secure', False) else 'FALSE'
                expiry = c.get('expiry')
                try:
                    expiry = int(expiry)
                except Exception:
                    expiry = 0
                name = c.get('name', '')
                value = c.get('value', '')

                include_subdomains = 'TRUE' if domain.startswith('.') else 'FALSE'

                f.write(f"{domain}\t{include_subdomains}\t{path}\t{secure}\t{expiry}\t{name}\t{value}\n")
        return True
    except Exception as e:
        print(f"Ошибка экспорта cookies: {e}")
        return False

def setup_selenium_driver():
    """Настраивает и возвращает Selenium WebDriver (uc -> ChromeDriver)"""
    from selenium.webdriver.chrome.service import Service
    from shutil import which

    chrome_options = Options()
    chrome_options.add_argument("--disable-blink-features=AutomationControlled")
    chrome_options.add_argument("--disable-dev-shm-usage")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--window-size=1920,1080")

    try:
        driver = uc.Chrome(options=chrome_options)
        return driver
    except Exception as e:
        print(f"Ошибка при настройке undetected-chromedriver: {e}")
        print("Пробуем использовать стандартный ChromeDriver...")

    try:
        chromedriver_path = which("chromedriver")
        service = Service(executable_path=chromedriver_path) if chromedriver_path else Service()
        driver = webdriver.Chrome(service=service, options=chrome_options)
        return driver
    except Exception as e2:
        print(f"Ошибка при настройке ChromeDriver: {e2}")
        return None

def automated_cookies_refresh():
    """Полу-ручное обновление cookies через Selenium: ты логинишься сам, мы только сохраняем."""
    print("\n" + "="*70)
    print("Автоматическое обновление cookies (ручной вход)...")
    print("="*70)

    driver = setup_selenium_driver()
    if not driver:
        print("Не удалось настроить Selenium. Пожалуйста, обновите cookies вручную.")
        return False

    try:
        driver.get("https://www.youtube.com/")
        print("\nВ открывшемся окне браузера войди в свой аккаунт YouTube/Google.")
        print("После успешного входа вернись в консоль и нажми Enter — я выгружу cookies.")
        input("Нажми Enter, когда войдёшь... ")

        try:
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "#avatar-btn"))
            )
            print("Похоже, ты залогинился. Экспортирую cookies...")
        except Exception:
            print("Не нашёл иконку профиля. Всё равно попробую сохранить cookies...")

        cookies_path = "cookies.txt"
        if export_cookies_selenium(driver, cookies_path):
            print("Cookies успешно обновлены и сохранены в cookies.txt!")
            return True
        else:
            print("Не удалось экспортировать cookies.")
            return False
    finally:
        try:
            time.sleep(2)
            driver.quit()
        except Exception:
            pass


def check_cookies_validity(cookies_file):
    """Проверяет валидность куки файла"""
    if not os.path.exists(cookies_file):
        return False
    
    try:
        cj = MozillaCookieJar(cookies_file)
        cj.load(ignore_discard=True, ignore_expires=True)
        
        required_cookies = ['SID', 'HSID', 'SSID', 'LOGIN_INFO']
        has_required = any(cookie.name in required_cookies for cookie in cj)
        
        now = time.time()
        for cookie in cj:
            if cookie.expires and cookie.expires < now:
                return False
                
        return has_required
    except Exception:
        return False

def refresh_cookies():
    """Просит пользователя обновить куки или делает это автоматически"""
    print("\n" + "="*70)
    print("Обнаружена проблема с куки файлом!")
    print("="*70)
    print("Выберите вариант:")
    print("1. Автоматическое обновление через Selenium (требует учетные данные YouTube)")
    print("2. Ручное обновление (экспорт через расширение браузера)")
    print("3. Продолжить без куки")
    print("="*70)
    
    response = input("Ваш выбор (1/2/3): ").strip()
    
    if response == '1':
        return automated_cookies_refresh()
    elif response == '2':
        print("\nПожалуйста, обновите куки файл вручную:")
        print("1. Убедитесь, что вы вошли в аккаунт YouTube в браузере")
        print("2. Экспортируйте куки с помощью расширения 'Get cookies.txt LOCALLY'")
        print("3. Сохраните файл как 'cookies.txt' в папке со скриптом")
        print("4. Нажмите Enter для продолжения")
        input()
        
        if os.path.exists('cookies.txt') and check_cookies_validity('cookies.txt'):
            print("Новые куки успешно загружены!")
            return True
        else:
            print("Не удалось найти valid куки файл. Продолжаем без куки...")
            return False
    else:
        print("Продолжаем без куки...")
        return False

def get_spotify_playlist_info(playlist_url):
    auth_manager = SpotifyClientCredentials(client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
    sp = spotipy.Spotify(auth_manager=auth_manager)
    
    playlist = sp.playlist(playlist_url)
    playlist_name = sanitize_filename(playlist['name'])
    owner_name = sanitize_filename(playlist['owner']['display_name'])
    tracks = []
    
    results = sp.playlist_items(playlist_url)
    while results:
        for item in results['items']:
            track = item['track']
            if track: 
                tracks.append({
                    'artist': ', '.join([artist['name'] for artist in track['artists']]),
                    'title': track['name'],
                    'album': track['album']['name'],
                    'duration_ms': track['duration_ms'],
                    'cover_url': track['album']['images'][0]['url'] if track['album']['images'] else None
                })
        if results['next']:
            results = sp.next(results)
        else:
            break
    
    return playlist_name, owner_name, tracks

def similarity(a, b):
    """Вычисляет схожесть между двумя строками"""
    return SequenceMatcher(None, a.lower(), b.lower()).ratio()

def find_best_match(track_info, ydl_opts, cookies_file=None):
    cache_key = f"{track_info['artist']} - {track_info['title']}"
    if cache_key in SEARCH_CACHE:
        if DEBUG:
            print(f"Используем кэшированный результат для: {cache_key}")
        return SEARCH_CACHE[cache_key]

    queries = [
        f"{track_info['artist']} - {track_info['title']} official audio",
        f"{track_info['artist']} - {track_info['title']}",
        f"{track_info['title']} {track_info['artist']}",
        f"{track_info['title']}",
    ]

    ydl_search_opts = dict(ydl_opts or {})
    ydl_search_opts.setdefault("quiet", True)
    ydl_search_opts.setdefault("no_warnings", True)
    ydl_search_opts.setdefault("extract_flat", True)
    ydl_search_opts.setdefault("noplaylist", True)
    ydl_search_opts.setdefault("prefer_ipv4", True)
    ydl_search_opts.setdefault("socket_timeout", 15)
    ydl_search_opts.setdefault("extractor_args", {"youtube": {"player_client": ["web"]}})

    if cookies_file and os.path.exists(cookies_file):
        ydl_search_opts["cookiefile"] = cookies_file

    all_results = []
    with youtube_dl.YoutubeDL(ydl_search_opts) as ydl:
        for query in queries:
            try:
                search_results = ydl.extract_info(f"ytsearch5:{query}", download=False)
                if search_results and 'entries' in search_results:
                    for entry in search_results['entries'] or []:
                        if entry and entry not in all_results:
                            all_results.append(entry)
            except Exception as e:
                if DEBUG:
                    print(f"Ошибка поиска для '{query}': {e}")
                continue

    if not all_results:
        if DEBUG:
            print(f"Не найдено результатов: {track_info['artist']} - {track_info['title']}")
        return None

    best_match = None
    best_score = -1.0
    spotify_duration = (track_info.get('duration_ms') or 0) / 1000.0  # сек

    if DEBUG:
        print(f"\nПоиск для: {track_info['artist']} - {track_info['title']}")
        print(f"Длительность Spotify: {spotify_duration:.2f} сек")
        print("Найденные варианты:")

    for i, entry in enumerate(all_results):
        if not entry:
            continue

        title = (entry.get('title') or "").strip()
        if not title:
            continue
        uploader = entry.get('uploader') or ""
        raw_dur = entry.get('duration')
        entry_duration = float(raw_dur) if raw_dur is not None else None

        title_similarity = similarity(title, track_info['title'])
        artist_in_title = similarity(title, track_info['artist'])

        if entry_duration is not None:
            duration_diff = abs(entry_duration - spotify_duration)
            duration_score = 1.0 / (1.0 + duration_diff)
        else:
            duration_diff = None
            duration_score = 0.5

        title_lower = title.lower()
        kw_bonus = 0.0
        if any(k in title_lower for k in ['official', 'original', 'audio', 'lyrics']):
            kw_bonus += 0.05
        if any(k in title_lower for k in ['cover', 'remix', 'speed up', 'sped up']):
            kw_bonus -= 0.2

        score = title_similarity * 0.65 + artist_in_title * 0.30 + duration_score * 0.05 + kw_bonus

        if DEBUG:
            dur_dbg = f"{int(entry_duration)}" if entry_duration is not None else "—"
            diff_dbg = f"{duration_diff:.2f}" if duration_diff is not None else "—"
            print(f"{i+1}. {title} | канал: {uploader} | длит.: {dur_dbg} | Δ={diff_dbg} | score={score:.3f}")

        if score > best_score and (duration_diff is None or duration_diff <= 20):
            best_score = score
            best_match = entry

    SEARCH_CACHE[cache_key] = best_match
    return best_match

def download_audio(track_info, output_dir, cookies_file=None):
    global COOKIES_NEED_REFRESH
    
    info_ydl_opts = {
        'quiet': True,
        'no_warnings': True,
        'extract_flat': True,
    }
    
    best_match = find_best_match(track_info, info_ydl_opts, cookies_file)
    
    if not best_match or 'url' not in best_match:
        print(f"Не удалось найти видео для: {track_info['artist']} - {track_info['title']}")
        return False
    
    video_url = best_match['url']
    
    download_ydl_opts = {
        'format': 'bestaudio/best',
        'outtmpl': os.path.join(output_dir, f"{sanitize_filename(track_info['artist'])} - {sanitize_filename(track_info['title'])}.%(ext)s"),
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '320',
        }],
        'quiet': True,
        'no_warnings': True,
        'socket_timeout': 30,
        'retries': 3,
        'fragment_retries': 3,
        'skip_unavailable_fragments': True,
        'continuedl': True,
    }
    
    if cookies_file and os.path.exists(cookies_file):
        download_ydl_opts['cookiefile'] = cookies_file
    
    try:
        with youtube_dl.YoutubeDL(download_ydl_opts) as ydl:
            ydl.download([video_url])
        return True
    except Exception as e:
        error_msg = str(e)
        if "Sign in to confirm your age" in error_msg:
            print(f"Обнаружена ошибка возрастного ограничения для: {track_info['title']}")
            COOKIES_NEED_REFRESH = True
            return "age_restricted"
        else:
            print(f"Ошибка загрузки {track_info['title']}: {error_msg}")
            return False

def add_metadata(track_info, file_path):
    try:
        audio = MP3(file_path, ID3=ID3)
        try:
            audio.add_tags()
        except error:
            pass
        
        audio.tags.add(TIT2(encoding=3, text=track_info['title']))
        audio.tags.add(TPE1(encoding=3, text=track_info['artist']))
        audio.tags.add(TALB(encoding=3, text=track_info['album']))
        
        if track_info['cover_url']:
            cover_path = os.path.join(os.path.dirname(file_path), "covers")
            os.makedirs(cover_path, exist_ok=True)
            cover_filename = f"{sanitize_filename(track_info['artist'])} - {sanitize_filename(track_info['title'])}.jpg"
            cover_filepath = os.path.join(cover_path, cover_filename)
            
            if not os.path.exists(cover_filepath):
                with urllib.request.urlopen(track_info['cover_url']) as img:
                    with open(cover_filepath, 'wb') as f:
                        f.write(img.read())
            
            with open(cover_filepath, 'rb') as img:
                audio.tags.add(APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,
                    desc='Cover',
                    data=img.read()
                ))
        audio.save(v2_version=3)
    except Exception as e:
        print(f"Ошибка добавления метаданных для {track_info['title']}: {str(e)}")

def process_track(args):
    idx, track, total, output_dir, cookies_file = args
    print(f"Скачивание [{idx}/{total}]: {track['artist']} - {track['title']}")
    
    result = download_audio(track, output_dir, cookies_file)
    if result is True:
        file_name = f"{sanitize_filename(track['artist'])} - {sanitize_filename(track['title'])}.mp3"
        file_path = os.path.join(output_dir, file_name)
        if os.path.exists(file_path):
            add_metadata(track, file_path)
            return None
        else:
            return f"{track['artist']} - {track['title']} (файл не создан)"
    elif result == "age_restricted":
        return f"{track['artist']} - {track['title']} (требуются куки)"
    else:
        return f"{track['artist']} - {track['title']} (ошибка загрузки)"

def main():
    global BASE_MUSIC_DIR

    BASE_MUSIC_DIR = ensure_music_dir(console)

    cookies_file = None
    if not CLI_SETTINGS.get("no_cookies", False):
        if os.path.exists('cookies.txt'):
            cookies_file = 'cookies.txt'
            console.print("[muted]Найден cookies.txt[/muted]")
            if not check_cookies_validity(cookies_file):
                console.print("[warn]cookies.txt недействителен или устарел[/warn]")


    while True:
        choice = show_main_menu()
        if choice == 0:
            console.print("\n[ok]Пока![/ok]")
            break
        elif choice == 1:
            cli_download_playlist(cookies_file)
        elif choice == 2:
            from single_track_cli import cli_download_single_track
            cli_download_single_track(
                cookies_file=cookies_file,
                sanitize_filename_func=sanitize_filename,
                client_id=CLIENT_ID,
                client_secret=CLIENT_SECRET,
                base_music_dir=BASE_MUSIC_DIR,
            )
        elif choice == 3:
            ok = automated_cookies_refresh()
            if ok:
                cookies_file = "cookies.txt"
        elif choice == 4:
            cli_check_cookies()
            Prompt.ask("\n[dim]Enter для возврата[/dim]", default="", show_default=False)
        elif choice == 5:
            cli_settings()
            Prompt.ask("\n[dim]Enter для возврата[/dim]", default="", show_default=False)
        elif choice == 6:
            cli_clear_cache()
            Prompt.ask("\n[dim]Enter для возврата[/dim]", default="", show_default=False)
        elif choice == 7:
            BASE_MUSIC_DIR = change_music_dir(console)



def show_main_menu() -> int:
    subtitle = f"[dim]Папка музыки:[/dim] {BASE_MUSIC_DIR or '(не задано)'}"
    options = [
        "Скачать плейлист по URL",
        "Скачать ОДИН трек (Spotify / YouTube)",
        "Обновить cookies (ручной вход в YouTube)",
        "Проверить cookies.txt",
        "Настройки",
        "Очистить кеш поиска",
        "Изменить папку музыки…",
    ]
    choice = ui_menu("Spotify Playlist Downloader", options, subtitle, back_text="⏻ Выход")
    return choice

def wait_enter():
    Prompt.ask("\n[muted]Нажми Enter, чтобы вернуться в меню[/muted]", default="", show_default=False)

# ==== NEW (CLI) ====
def cli_download_playlist(cookies_file: str | None):
    # Страница №1 — запрос URL
    ui_page("Скачать плейлист", "Вставь URL плейлиста Spotify. Если передумал — введи 0.")
    playlist_url = prompt_cancelable("URL плейлиста")
    if playlist_url is None or not playlist_url:
        return

    # Страница №2 — получаем инфу
    ui_page("Скачать плейлист", "[muted]Получаю информацию о плейлисте...[/muted]")
    try:
        playlist_name, owner_name, tracks = get_spotify_playlist_info(playlist_url)
    except Exception as e:
        ui_page("Скачать плейлист", f"[red]Ошибка Spotify API:[/red] {e}\n\n[dim]Нажми Enter для возврата[/dim]")
        Prompt.ask("", default="", show_default=False)
        return

    if not tracks:
        ui_page("Скачать плейлист", "[yellow]В плейлисте не нашлось треков[/yellow]\n\n[dim]Enter для возврата[/dim]")
        Prompt.ask("", default="", show_default=False)
        return

    subtitle = f"[ok]Найдено треков:[/ok] {len(tracks)}\n[dim]{playlist_name} — {owner_name}[/dim]"
    ui_page("Скачать плейлист", subtitle)

    # Создаём подпапку в BASE_MUSIC_DIR
    base_dir_name = f"{playlist_name} ({owner_name})"
    output_dir = os.path.join(BASE_MUSIC_DIR, base_dir_name)
    counter = 1
    while os.path.exists(output_dir):
        output_dir = os.path.join(BASE_MUSIC_DIR, f"{base_dir_name}_{counter}")
        counter += 1
    os.makedirs(output_dir, exist_ok=True)

    # 1) Поиск кандидатов
    info_ydl_opts = {'quiet': True, 'no_warnings': True, 'extract_flat': True}
    if cookies_file and os.path.exists(cookies_file):
        info_ydl_opts['cookiefile'] = cookies_file

    ui_page("Скачать плейлист", "[title]Поиск треков на YouTube[/title]")
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TextColumn("{task.completed}/{task.total}"),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        t1 = progress.add_task("Поиск...", total=len(tracks))
        for track in tracks:
            find_best_match(track, info_ydl_opts, cookies_file)
            progress.update(t1, advance=1)

    # 2) Загрузка
    ui_page("Скачать плейлист", "[title]Загрузка аудио[/title]")
    failed_tracks = []
    age_restricted_tracks = []

    def _worker(args):
        return process_track(args)

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TextColumn("{task.completed}/{task.total}"),
        TimeElapsedColumn(),
        console=console,
    ) as progress:
        t2 = progress.add_task("Скачивание...", total=len(tracks))
        with concurrent.futures.ThreadPoolExecutor(max_workers=CLI_SETTINGS["threads"]) as executor:
            args_list = [(idx, track, len(tracks), output_dir, cookies_file) for idx, track in enumerate(tracks, 1)]
            for res in executor.map(_worker, args_list):
                if res:
                    if "(требуются куки)" in res:
                        age_restricted_tracks.append(res)
                    else:
                        failed_tracks.append(res)
                progress.update(t2, advance=1)

    if age_restricted_tracks:
        ui_page("Скачать плейлист", f"[warn]Треки с возрастным ограничением: {len(age_restricted_tracks)}[/warn]")
        if Confirm.ask("Обновить cookies и попробовать ещё раз?"):
            if refresh_cookies():
                cookies_file = 'cookies.txt'
                retry_track_names = [t.split(' (требуются куки)')[0] for t in age_restricted_tracks]
                retry_tracks = [t for t in tracks if f"{t['artist']} - {t['title']}" in retry_track_names]

                age_restricted_tracks = []

                ui_page("Скачать плейлист", "[title]Повторная загрузка[/title]")
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    BarColumn(),
                    TextColumn("{task.completed}/{task.total}"),
                    TimeElapsedColumn(),
                    console=console,
                ) as progress:
                    t3 = progress.add_task("Скачивание...", total=len(retry_tracks))
                    with concurrent.futures.ThreadPoolExecutor(max_workers=CLI_SETTINGS["threads"]) as executor:
                        args_list = [(idx, track, len(retry_tracks), output_dir, cookies_file) for idx, track in enumerate(retry_tracks, 1)]
                        for res in executor.map(_worker, args_list):
                            if res:
                                if "(требуются куки)" in res:
                                    age_restricted_tracks.append(res)
                                else:
                                    failed_tracks.append(res)
                            progress.update(t3, advance=1)

    if failed_tracks or age_restricted_tracks:
        msg = "[warn]Не удалось скачать:[/warn]\n" + "\n".join(f" • {t}" for t in (failed_tracks + age_restricted_tracks))
    else:
        msg = "[ok]Готово! Все треки скачаны.[/ok]"
    ui_page("Скачать плейлист", f"{msg}\n\n[dim]Папка:[/dim] {output_dir}\n\n[dim]Enter для возврата[/dim]")
    Prompt.ask("", default="", show_default=False)


# ==== NEW (CLI) ====
def cli_check_cookies():
    path = "cookies.txt"
    if not os.path.exists(path):
        console.print("[warn]cookies.txt не найден[/warn]")
        return
    ok = check_cookies_validity(path)
    console.print("[ok]cookies.txt валиден[/ok]" if ok else "[warn]cookies.txt недействителен или устарел[/warn]")

def cli_settings():
    console.print("\n[title]Настройки[/title]")
    console.print(f"Текущие: threads={CLI_SETTINGS['threads']}, debug={CLI_SETTINGS['debug']}")
    if Confirm.ask("Изменить число потоков?"):
        CLI_SETTINGS["threads"] = IntPrompt.ask("threads", default=CLI_SETTINGS["threads"])
    if Confirm.ask("Переключить DEBUG?"):
        CLI_SETTINGS["debug"] = not CLI_SETTINGS["debug"]
        global DEBUG
        DEBUG = CLI_SETTINGS["debug"]
    console.print(f"[ok]Сохранено: threads={CLI_SETTINGS['threads']}, debug={CLI_SETTINGS['debug']}[/ok]")

def cli_clear_cache():
    SEARCH_CACHE.clear()
    console.print("[ok]Кеш поиска очищен[/ok]")

def ui_page(title: str, subtitle: str | None = None):
    """Чистит консоль и рисует «страницу» с заголовком и пояснением."""
    console.clear()
    console.print(Panel.fit(
        (subtitle or ""),
        title=title,
        border_style="title"
    ))

def ui_menu(title: str, options: list[str], subtitle: str | None = None, back_text: str = "⟵ Назад") -> int:
    """
    Рисует страницу-меню. Возвращает выбранный номер:
      0 — «Назад», 1..N — пункт из options.
    """
    ui_page(title, subtitle)
    table = Table(show_header=True, header_style="title")
    table.add_column("#", justify="right", style="muted", width=3)
    table.add_column("Действие", style="ok")
    table.add_row("0", back_text)
    for i, opt in enumerate(options, start=1):
        table.add_row(str(i), opt)
    console.print(table)
    choice = IntPrompt.ask("Выбери пункт", choices=[str(i) for i in range(0, len(options)+1)])
    return int(choice)

def prompt_cancelable(label: str, default: str = "") -> str | None:
    """
    Prompt с подсказкой про «0 — Назад».
    Возвращает None, если пользователь ввёл 0 (отмена).
    """
    val = Prompt.ask(f"{label} [dim](0 — назад)[/dim]", default=default)
    if val.strip() == "0":
        return None
    return val.strip()

if __name__ == "__main__":
    main()